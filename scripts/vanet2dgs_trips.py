from lxml import etree
import sys
import fileinput
from xml.sax.saxutils import XMLGenerator
from xml.sax.xmlreader import AttributesNSImpl
from optparse import OptionParser
from dgsWriter import *
from numpy import * 

parser = OptionParser("usage: %prog [options]")
parser.add_option('--vanetFile', help=("VANET file."), type="string", dest="vanetFile")
parser.add_option('--tripsFile', help=("trips file."), type="string", dest="tripsFile")
parser.add_option('--dgsFile', help=("DGS output"), type="string", dest='dgsFile')
parser.add_option('--fromNS3', help=("If the vanet file was generated by NS3 (contains MAC address)"), action='store_true', default=False, dest="fromNS3" )
(options, args) = parser.parse_args()

print options

# check set options
if not options.vanetFile or not options.dgsFile:
	print "Usage: vanet2dgs --vanetFile <FILE> --dgsFile <FILE>" 
	print "[--fromNS3]"
	print "Exiting..."
	exit()

macMap = {}
mapIdMac = {}
currentStep = -1
stepVehicles = {}
runningVehicles = {}
runningEdgesCount = 0
stepPoints = {}
stepVehiclesAttr = {}
edgesCount = 0
nodesCount = 0
edgesStepCount = 0
deletedNodesCount = 0
addedNodesCount = 0

maxEdgeDistance = 0
sumEdgeDistance = 0
countEdgeDistances = 0 

def populateMacMap(elem, args={}):
	#print line	
	global macMap
	elem = line.split(args.separator)
	if len(elem) > 5:
		vehicleId = str(elem[2])
		vehicleMac = str(elem[11])
		macMap[vehicleMac] = vehicleId
		mapIdMac[vehicleId] = vehicleMac
	return 

def calculateDistance(p0, p1):
	deltaX = p0[0] - p1[0]
	deltaY = p0[1] - p1[1]
	# print "deltaX: {}, deltaY: {}".format(deltaX, deltaY)
	distance = math.sqrt((p0[0] - p1[0])*(p0[0] - p1[0]) + (p0[1] - p1[1])*(p0[1] - p1[1]))
	return distance
		
def formatEdgeId(node1, node2):
	# nodeMac1 = mapIdMac(node1)
	# nodeMac2 = mapIdMac(node2)
	edgeId = "{0}-{1}".format(node1,node2)
	if node2 < node1:
		edgeId = "{1}-{0}".format(node1,node2)
	return edgeId

def splitEdgeId(edgeId):
	return edgeId.split("-")

# def edgeExist(edges, node1, node2):
# 	edgeId = formatEdgeId(node1, node2)
# 	edgeIdReverse = formatEdgeId(node2, node1)
# 	return (edgeId in edges or edgeIdReverse in edges)

def checkEdges(stepVehicles, stepPoints):
	global maxEdgeDistance
	global countEdgeDistances
	global sumEdgeDistance 
	maxEdgeDistance = 0
	countEdgeDistances = 0
	sumEdgeDistance = 0
	for stepVehicleId,stepVehicleEdges in stepVehicles.iteritems():
		point1 = stepPoints[stepVehicleId]
		for neighborId in stepVehicleEdges:
			point2 = stepPoints[neighborId]
			distance = calculateDistance(point1, point2)
			countEdgeDistances += 1
			sumEdgeDistance += distance
			if distance > maxEdgeDistance:
				maxEdgeDistance = distance
	return

def getRunningEdges(runningVehicles):
	runningEdgesCount = 0
	for vehicleId,vehicleEdges in runningVehicles.iteritems():
		runningEdgesCount += len(vehicleEdges)
	return runningEdgesCount			

def processLine(line, args={}):
	#print line	
	global currentStep
	global macMap
	global stepVehicles
	global stepVehiclesAttr
	global stepPoints
	global runningVehicles
	global edges 
	global nodesCount
	global edgesCount
	global edgesStepCount
	global maxEdgeDistance
	global sumEdgeDistance 
	global countEdgeDistances
	global runningEdgesCount

	elem = line.split(args["separator"])
	step = float(elem[0])
	
	# next step
	# populate array removedVehicles with vehicles who were in the previous step but are not in the step any more
	# write del in dgs
	if step != currentStep:	
		currentStep = step
		dgsWriter.writeStep(step)

		if len(stepVehicles) > 0:
			print "----"
			print "step: {0}, stepVehicles: {1}, stepPoints: {2}, stepEdges: {3}".format(currentStep, len(stepVehicles), len(stepPoints), edgesStepCount)
			print "step: {0}, runningVehicles: {1} runningEdges: {2}".format(currentStep, len(runningVehicles), getRunningEdges(runningVehicles))
			
			nodesToDelete = []
			addedNodesCount = 0
			edgesToAdd = []
			nodesToAdd = []
			edgesToDelete = []
			runningEdgesCount = 0
					
			# if a step vehicle is not in running, add, if is , write change
			for stepVehicleId,stepVehicleEdges in stepVehicles.iteritems():
				point = stepPoints[stepVehicleId]
				vehicleAttr = stepVehiclesAttr[stepVehicleId]
				# if stepVehicleId == "337" or stepVehicleId == "344":
				# 	print "step node {0}: {1}".format(stepVehicleId, stepVehicleEdges)
				if not stepVehicleId in runningVehicles.keys():
					addedNodesCount += 1
					runningVehicles[stepVehicleId] = stepVehicleEdges
					# print "vehicleAttr {0} {1}".format(stepVehicleId, vehicleAttr)
					# wrtie added nodes 
					# id = mapIdMac(stepVehicleId)
					dgsWriter.writeAddNode(stepVehicleId, vehicleAttr, point[0], point[1])
					# remember which edges to add
					for edgeToAdd in stepVehicleEdges:
						edgeId = formatEdgeId(stepVehicleId, edgeToAdd)
						if edgeToAdd not in runningVehicles.keys():
							runningVehicles[edgeToAdd] = []
							nodesToAdd.append(edgeToAdd)
							addedNodesCount += 1
							point = stepPoints[edgeToAdd]
							vehicleAttr = stepVehiclesAttr[edgeToAdd]
							# id = mapIdMac(edgeToAdd)
							dgsWriter.writeAddNode(edgeToAdd, vehicleAttr, point[0], point[1])
						if edgeId not in edgesToAdd:
							edgesToAdd.append(edgeId)
					runningEdgesCount += len(runningVehicles[stepVehicleId])

				else:
					# write changed nodes
					if (stepVehicleId not in nodesToAdd):
						# id = mapIdMac(stepVehicleId)
						dgsWriter.writeChangeNode(stepVehicleId, vehicleAttr, point[0], point[1])
					
					# add/delete edges if changed 
					for newEdge in stepVehicleEdges:
						if newEdge not in runningVehicles[stepVehicleId]:
							edgeId = formatEdgeId(stepVehicleId, newEdge)			
							if edgeId not in edgesToAdd:
								edgesToAdd.append(edgeId)
							runningVehicles[stepVehicleId].append(newEdge)
					neighborsToRemove = []
					for currentEdge in runningVehicles[stepVehicleId]:
						if not currentEdge in stepVehicleEdges:
							# print "{0}-{1}".format(stepVehicleId, currentEdge)
							edgeId = formatEdgeId(stepVehicleId, currentEdge)
							if edgeId not in edgesToDelete:
								edgesToDelete.append(edgeId)
							neighborsToRemove.append(currentEdge)
					for neighborToRemove in neighborsToRemove:
						runningVehicles[stepVehicleId].remove(neighborToRemove)
						
					runningEdgesCount += len(runningVehicles[stepVehicleId])			

			# if a running vehice is not in the current step, remove from running
			for runningVehicleId in runningVehicles.iterkeys():
				if not runningVehicleId in stepVehicles:
					nodesToDelete.append(runningVehicleId)
			for nodeId in nodesToDelete:
				for edgeToDelete in runningVehicles[nodeId]:
					edgeId = formatEdgeId(nodeId, edgeToDelete)
					if edgeId not in edgesToDelete:
						edgesToDelete.append(edgeId)
				runningVehicles = removekey(runningVehicles, nodeId)

			# wrtite added edges
			for edgeId in edgesToAdd:
				edges = splitEdgeId(edgeId)
				if len(edges) == 2:
					distance = calculateDistance(stepPoints[edges[0]], stepPoints[edges[1]])
					dgsWriter.writeAddEdgeWeight(edgeId, edges[0], edges[1], distance)
				else:
					print "Error. EdgeId in wrong format!"
			# write deleted edges
			for edgeId in edgesToDelete:
				# id = mapIdMac(edgeId)
				dgsWriter.writeDelEdge(edgeId)
			# write deleted nodes
			for nodeId in nodesToDelete:
				# id = mapIdMac(nodeId)
				dgsWriter.writeDelNode(nodeId)	
			
			print "step: {0}, addedNodes: {1}, deletedNodes {2}, edgesToAdd: {3}, edgesToDelete: {4} ".format(currentStep, addedNodesCount, len(nodesToDelete), len(edgesToAdd), len(edgesToDelete))
			print "step: {0}, after step runningVehicles: {1} runningEdges: {2}, runningEdgesCount: {3}".format(currentStep, len(runningVehicles), getRunningEdges(runningVehicles), runningEdgesCount)
			
			checkEdges(stepVehicles, stepPoints)
			if countEdgeDistances > 0:
				print "step: {0}, maxEdgeDistance: {1}, avg distance: {2}".format(currentStep, maxEdgeDistance, sumEdgeDistance/countEdgeDistances)

		# prepare to the next step
		
		edgesCount += edgesStepCount
		nodesCount += len(stepVehicles)
		edgesStepCount = 0
		
		addedNodesCount = 0
		deletedNodsCount = 0

		stepVehicles = {}
		stepVehiclesAttr = {}
		stepPoints = {}

	# record step vehicle information (id, point, edges)
	# vehicleId = str(elem[2])
	#[0]step, 	[1]time, 	[2]id, 	[3]slope, 	[4]lane, 		[5]angle, 	[6]speed, 	[7]pos, 	[8]x, 			[9]y, 			[10]type, 		[11]vehicleId,	[12]numberOfNeighbors, 	[13]neighbors
	#[0]1, 		[1]21631.0,	[2]2,	[3]0.00,	[4]-9234280_1,	[5]-116.40,	[6]24.66,	[7]85.73,	[8]19076.21,	[9]22800.23,	[10]porsche,	[11]_h5_4352,	[12]1,					[13]_h5_4416
	
	vehicle = {}
	for index in args["floatIndexes"]:
		vehicle[index] = float(elem[args["floatIndexes"][index]])
	for index in args["strIndexes"]:
		vehicle[index] = str(elem[args["strIndexes"][index]])
	for index in args["intIndexes"]:
		vehicle[index] = int(elem[args["intIndexes"][index]])
	
	vehicleEdges = []
	for i in range(0,vehicle["vehicleNumberOfEdges"]):
		neighborId = str(elem[args["edgesIndex"]+i]).strip()
		vehicleEdges.append(neighborId)
		edgesStepCount += 1

	vehicleId = vehicle["vehicleId"]
	stepVehicles[vehicleId] = vehicleEdges
	stepVehiclesAttr[vehicleId] = {
		'vehicleSpeed':vehicle["vehicleSpeed"], 'vehicleLane':vehicle["vehicleLane"], 'vehiclePos':vehicle["vehiclePos"]}
	if "vehicleAngle" in vehicle:
		stepVehiclesAttr['vehicleAngle'] = vehicle["vehicleAngle"]
		stepVehiclesAttr['vehicleSlope'] = vehicle["vehicleSlope"]
		
	if vehicleId in vehicles: 
		stepVehiclesAttr[vehicleId]['edges'] = vehicles[vehicleId]['edges']
	stepPoints[vehicleId] = [vehicle["vehicleX"],vehicle["vehicleY"]]
	
	return 0


def removekey(d, key):
    r = dict(d)
    del r[key]
    return r

def fastIter(context, processElement, args={}):	

	vehicleEl = {}	
	for event, elem in context:
		if event == 'start':
			if elem.tag == "vehicle":
				vehicleEl = {}	
				vehicleEl['id'] = elem.attrib['id']
				vehicleEl['depart'] = elem.attrib['depart']
				vehicleEl['arrival'] = elem.attrib['arrival']
			if elem.tag == "route":
				vehicleEl['edges'] = elem.attrib['edges']
		if event == 'end':
			if elem.tag == "vehicle":
				print "vehicle {0}".format(vehicleEl)
				vehicles[vehicleEl['id']] = vehicleEl
				while elem.getprevious() is not None:
					del elem.getparent()[0]
		elem.clear()
	del context
	return

def processVehicle(elem, args={}):
	# print "elem {0}: {1}".format(elem.tag, elem.keys())
	if elem.tag == "routeDist":
		
		print "vehicle {0}\trouteDist {1}".format(vehicleEl['id'], routeDist)
	return 

#################

vehicles = {}

# read ttrips of vehicles first 
if options.tripsFile:
	context = etree.iterparse(options.tripsFile, events=('start','end'))
	fastIter(context, processVehicle, args)


args = {}
if "probeData" in options.vanetFile:
	#STEP2.0	2time.0	id0	linkId,1606	offset,10.8298848863	y,2440.82988489	x,2423.5	speed,57.4572273833	id,8	0
	args["floatIndexes"] = {"step":0, "time":1, "id": 2, "vehiclePos": 4, "vehicleY": 5, "vehicleX": 6, "vehicleSpeed": 7}
	args["intIndexes"] = {"vehicleNumberOfEdges": 9, "vehicleLane": 3}
	args["edgesIndex"] = 10
	args["strIndexes"] = { "vehicleId": 8}
	args["separator"] = "\t"
else:
	#step, time, id, slope, lane, angle, speed, pos, x, y, type, vehicleId, numberOfNeighbors, neighbors
	#2,21632.0,2,22763.76,19092.69,0.00,-84201885_1,-114.61,22.42,15.60,19092.69,22763.76,porsche,_h5_4352,1,_h5_4416
	args["floatIndexes"] = {"vehicleSlope":3, "vehicleAngle": 5, "vehicleSpeed": 6, "vehiclePos": 7, "vehicleX": 9, "vehicleY": 8}
	args["strIndexes"] = {"vehicleId": 11, "vehicleLane": 4}
	args["intIndexes"] = {"vehicleNumberOfEdges": 12}
	args["edgesIndex"] = 13
	args["separator"] = "\t"

dgsWriter = DGSWriter(options.dgsFile)
dgsWriter.writeHeader("DGS004", "vanet", 0, 0)

# populateMacMap(line, args)
for line in fileinput.input(options.vanetFile):
	processLine(line, args)

print "vehicles trips {0}, stepVehiclesAttr {1}".format(len(vehicles), len(stepVehiclesAttr))

print "nodesCount: " + str(nodesCount) + ", edgesCount: " + str(edgesCount)
