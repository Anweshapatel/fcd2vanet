from lxml import etree
import sys
import fileinput
from xml.sax.saxutils import XMLGenerator
from xml.sax.xmlreader import AttributesNSImpl
from optparse import OptionParser
from dgsWriter import *
from numpy import * 

parser = OptionParser("usage: %prog [options]")
parser.add_option('--vanetFile', help=("VANET file."), type="string", dest="vanetFile")
parser.add_option('--dgsFile', help=("DGS output"), type="string", dest='dgsFile')
parser.add_option('--fromNS3', help=("If the vanet file was generated by NS3 (contains MAC address)"), action='store_true', default=False, dest="fromNS3" )
(options, args) = parser.parse_args()

print options

# check set options
if not options.vanetFile or not options.dgsFile:
	print "Usage: vanet2dgs --vanetFile <FILE> --dgsFile <FILE>" 
	print "[--fromNS3]"
	print "Exiting..."
	exit()

macMap = {}
mapIdMac = {}
currentStep = -1
stepVehicles = {}
runningVehicles = {}
runningEdgesCount = 0
stepPoints = {}

edgesCount = 0
nodesCount = 0
edgesStepCount = 0
deletedNodesCount = 0
addedNodesCount = 0

maxEdgeDistance = 0
sumEdgeDistance = 0
countEdgeDistances = 0 

def populateMacMap(elem, args={}):
	#print line	
	global macMap
	elem = line.split(',')
	if len(elem) > 5:
		vehicleId = str(elem[2])
		vehicleMac = str(elem[5])
		macMap[vehicleMac] = vehicleId
		mapIdMac[vehicleId] = vehicleMac
	return 

def calculateDistance(p0, p1):
	deltaX = p0[0] - p1[0]
	deltaY = p0[1] - p1[1]
	# print "deltaX: {}, deltaY: {}".format(deltaX, deltaY)
	distance = math.sqrt((p0[0] - p1[0])*(p0[0] - p1[0]) + (p0[1] - p1[1])*(p0[1] - p1[1]))
	return distance
		
def formatEdgeId(node1, node2):
	# nodeMac1 = mapIdMac(node1)
	# nodeMac2 = mapIdMac(node2)
	edgeId = "{0}-{1}".format(node1,node2)
	if node2 < node1:
		edgeId = "{1}-{0}".format(node1,node2)
	return edgeId

def splitEdgeId(edgeId):
	return edgeId.split("-")

# def edgeExist(edges, node1, node2):
# 	edgeId = formatEdgeId(node1, node2)
# 	edgeIdReverse = formatEdgeId(node2, node1)
# 	return (edgeId in edges or edgeIdReverse in edges)

def checkEdges(stepVehicles, stepPoints):
	global maxEdgeDistance
	global countEdgeDistances
	global sumEdgeDistance 
	maxEdgeDistance = 0
	countEdgeDistances = 0
	sumEdgeDistance = 0
	for stepVehicleId,stepVehicleEdges in stepVehicles.iteritems():
		point1 = stepPoints[stepVehicleId]
		for neighborId in stepVehicleEdges:
			point2 = stepPoints[neighborId]
			distance = calculateDistance(point1, point2)
			countEdgeDistances += 1
			sumEdgeDistance += distance
			if distance > maxEdgeDistance:
				maxEdgeDistance = distance
	return

def getRunningEdges(runningVehicles):
	runningEdgesCount = 0
	for vehicleId,vehicleEdges in runningVehicles.iteritems():
		runningEdgesCount += len(vehicleEdges)
	return runningEdgesCount			

def processLine(line, args={}):
	#print line	
	global currentStep
	global macMap
	global stepVehicles
	global stepPoints
	global runningVehicles
	global edges 
	global nodesCount
	global edgesCount
	global edgesStepCount
	global maxEdgeDistance
	global sumEdgeDistance 
	global countEdgeDistances
	global runningEdgesCount

	#1 21631 21 23094 21968.5 00:00:00:00:00:16 2 00:00:00:00:00:20,1 00:00:00:00:01:f7,1 
	elem = line.split(',')
	step = float(elem[0])
	
	# next step
	# populate array removedVehicles with vehicles who were in the previous step but are not in the step any more
	# write del in dgs
	if step != currentStep:	
		currentStep = step
		
		dgsWriter.writeStep(step)

		if len(stepVehicles) > 0:

			print "----"
			print "step: {0}, stepVehicles: {1}, stepPoints: {2}, stepEdges: {3}".format(currentStep, len(stepVehicles), len(stepPoints), edgesStepCount)
			print "step: {0}, runningVehicles: {1} runningEdges: {2}".format(currentStep, len(runningVehicles), getRunningEdges(runningVehicles))
			
			nodesToDelete = []
			addedNodesCount = 0
			edgesToAdd = []
			nodesToAdd = []
			edgesToDelete = []
			runningEdgesCount = 0
					
			# if a step vehicle is not in running, add, if is , write change
			for stepVehicleId,stepVehicleEdges in stepVehicles.iteritems():
				point = stepPoints[stepVehicleId]
				
				# if stepVehicleId == "337" or stepVehicleId == "344":
				# 	print "step node {0}: {1}".format(stepVehicleId, stepVehicleEdges)
				if not stepVehicleId in runningVehicles.keys():
					addedNodesCount += 1
					runningVehicles[stepVehicleId] = stepVehicleEdges
					# wrtie added nodes 
					# id = mapIdMac(stepVehicleId)
					dgsWriter.writeAddNode(stepVehicleId, point[0], point[1])
					# remember which edges to add
					for edgeToAdd in stepVehicleEdges:
						edgeId = formatEdgeId(stepVehicleId, edgeToAdd)
						if edgeToAdd not in runningVehicles.keys():
							runningVehicles[edgeToAdd] = []
							nodesToAdd.append(edgeToAdd)
							addedNodesCount += 1
							point = stepPoints[edgeToAdd]
							# id = mapIdMac(edgeToAdd)
							dgsWriter.writeAddNode(edgeToAdd, point[0], point[1])
						if edgeId not in edgesToAdd:
							edgesToAdd.append(edgeId)
					runningEdgesCount += len(runningVehicles[stepVehicleId])

				else:
					# write changed nodes
					if (stepVehicleId not in nodesToAdd):
						# id = mapIdMac(stepVehicleId)
						dgsWriter.writeChangeNode(stepVehicleId, point[0], point[1])
					
					# add/delete edges if changed 
					for newEdge in stepVehicleEdges:
						if newEdge not in runningVehicles[stepVehicleId]:
							edgeId = formatEdgeId(stepVehicleId, newEdge)			
							if edgeId not in edgesToAdd:
								edgesToAdd.append(edgeId)
							runningVehicles[stepVehicleId].append(newEdge)
					neighborsToRemove = []
					for currentEdge in runningVehicles[stepVehicleId]:
						if not currentEdge in stepVehicleEdges:
							# print "{0}-{1}".format(stepVehicleId, currentEdge)
							edgeId = formatEdgeId(stepVehicleId, currentEdge)
							if edgeId not in edgesToDelete:
								edgesToDelete.append(edgeId)
							neighborsToRemove.append(currentEdge)
					for neighborToRemove in neighborsToRemove:
						runningVehicles[stepVehicleId].remove(neighborToRemove)
						
					runningEdgesCount += len(runningVehicles[stepVehicleId])			

			# if a running vehice is not in the current step, remove from running
			for runningVehicleId in runningVehicles.iterkeys():
				if not runningVehicleId in stepVehicles:
					nodesToDelete.append(runningVehicleId)
			for nodeId in nodesToDelete:
				for edgeToDelete in runningVehicles[nodeId]:
					edgeId = formatEdgeId(nodeId, edgeToDelete)
					if edgeId not in edgesToDelete:
						edgesToDelete.append(edgeId)
				runningVehicles = removekey(runningVehicles, nodeId)

			# wrtite added edges
			for edgeId in edgesToAdd:
				edges = splitEdgeId(edgeId)
				if len(edges) == 2:
					distance = calculateDistance(stepPoints[edges[0]], stepPoints[edges[1]])
					dgsWriter.writeAddEdge(edgeId, edges[0], edges[1])
				else:
					print "Error. EdgeId in wrong format!"
			# write deleted edges
			for edgeId in edgesToDelete:
				# id = mapIdMac(edgeId)
				dgsWriter.writeDelEdge(edgeId)
			# write deleted nodes
			for nodeId in nodesToDelete:
				# id = mapIdMac(nodeId)
				dgsWriter.writeDelNode(nodeId)	
			
			print "step: {0}, addedNodes: {1}, deletedNodes {2}, edgesToAdd: {3}, edgesToDelete: {4} ".format(currentStep, addedNodesCount, len(nodesToDelete), len(edgesToAdd), len(edgesToDelete))
			print "step: {0}, after step runningVehicles: {1} runningEdges: {2}, runningEdgesCount: {3}".format(currentStep, len(runningVehicles), getRunningEdges(runningVehicles), runningEdgesCount)
			
			checkEdges(stepVehicles, stepPoints)
			if countEdgeDistances > 0:
				print "step: {0}, maxEdgeDistance: {1}, avg distance: {2}".format(currentStep, maxEdgeDistance, sumEdgeDistance/countEdgeDistances)

		# prepare to the next step
		
		edgesCount += edgesStepCount
		nodesCount += len(stepVehicles)
		edgesStepCount = 0
		
		addedNodesCount = 0
		deletedNodsCount = 0

		stepVehicles = {}
		stepPoints = {}

	# record step vehicle information (id, point, edges)
	# vehicleId = str(elem[2])
	vehicleId = str(elem[5])
	vehicleX = float(elem[3])
	vehicleY = float(elem[4])
	vehicleMac = str(elem[5])
	vehicleNumberOfEdges = int(elem[6])
	vehicleEdges = []
	for i in range(0,vehicleNumberOfEdges):
		neighborId = str(elem[7+i]).strip()
		# if options.fromNS3:
		# 	neighborId = macMap[elem[7+i]]
		vehicleEdges.append(neighborId)
		edgesStepCount += 1

	stepVehicles[vehicleId] = vehicleEdges
	stepPoints[vehicleId] = [vehicleX,vehicleY]
	
	return 0


def removekey(d, key):
    r = dict(d)
    del r[key]
    return r


#################

dgsWriter = DGSWriter(options.dgsFile)
dgsWriter.writeHeader("DGS004", "vanet", 0, 0)
# populateMacMap(line, args)
for line in fileinput.input(options.vanetFile):
	processLine(line, args)

print "nodesCount: " + str(nodesCount) + ", edgesCount: " + str(edgesCount)
