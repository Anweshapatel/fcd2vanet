from lxml import etree
import sys
import fileinput
from xml.sax.saxutils import XMLGenerator
from xml.sax.xmlreader import AttributesNSImpl
from optparse import OptionParser
from dgsWriter import *
from numpy import * 

parser = OptionParser("usage: %prog [options]")
parser.add_option('--vanetFile', help=("VANET file."), type="string", dest="vanetFile")
parser.add_option('--dgsFile', help=("DGS output"), type="string", dest='dgsFile')
parser.add_option('--fromNS3', help=("If the vanet file was generated by NS3 (contains MAC address)"), action='store_true', default=False, dest="fromNS3" )
(options, args) = parser.parse_args()

print options

# check set options
if not options.vanetFile or not options.dgsFile:
	print "Usage: vanet2dgs --vanetFile <FILE> --dgsFile <FILE>" 
	print "[--fromNS3]"
	print "Exiting..."
	exit()

macMap = {}
currentStep = -1
stepVehicles = {}
runningVehicles = {}
stepPoints = {}

edgesCount = 0
nodesCount = 0
edgesStepCount = 0
deletedNodesCount = 0
addedNodesCount = 0

maxEdgeDistance = 0
sumEdgeDistance = 0
countEdgeDistances = 0 

def populateMacMap(elem, args={}):
	#print line	
	global macMap
	elem = line.split(',')
	if len(elem) > 5:
		vehicleId = str(elem[2])
		vehicleMac = str(elem[5])
		macMap[vehicleMac] = vehicleId
	return 

def calculateDistance(p0, p1):
	deltaX = p0[0] - p1[0]
	deltaY = p0[1] - p1[1]
	# print "deltaX: {}, deltaY: {}".format(deltaX, deltaY)
	distance = math.sqrt((p0[0] - p1[0])*(p0[0] - p1[0]) + (p0[1] - p1[1])*(p0[1] - p1[1]))
	return distance
		
def formatEdgeId(node1, node2):
	nodeNum1 = int(node1)
	nodeNum2 = int(node2)
	edgeId = "{0}-{1}".format(node1,node2)
	if nodeNum2 < nodeNum1:
		edgeId = "{1}-{0}".format(node1,node2)
	return edgeId

def splitEdgeId(edgeId):
	return edgeId.split("-")

# def edgeExist(edges, node1, node2):
# 	edgeId = formatEdgeId(node1, node2)
# 	edgeIdReverse = formatEdgeId(node2, node1)
# 	return (edgeId in edges or edgeIdReverse in edges)

def checkEdges(stepVehicles, stepPoints):
	global maxEdgeDistance
	for stepVehicleId,stepVehicleEdges in stepVehicles.iteritems():
		point1 = stepPoints[stepVehicleId]
		for neighborId in stepVehicleEdges:
			point2 = stepPoints[neighborId]
			distance = calculateDistance(point1, point2)
			if distance > maxEdgeDistance:
				maxEdgeDistance = distance
	return

def processLine(line, args={}):
	#print line	
	global currentStep
	global macMap
	global stepVehicles
	global stepPoints

	global runningVehicles

	global edges 
	global nodesCount
	global edgesCount
	global edgesStepCount
	
	global maxEdgeDistance
	global sumEdgeDistance 
	global countEdgeDistances

	#1 21631 21 23094 21968.5 00:00:00:00:00:16 2 00:00:00:00:00:20,1 00:00:00:00:01:f7,1 
	elem = line.split(',')
	step = float(elem[0])
	
	# next step
	# populate array removedVehicles with vehicles who were in the previous step but are not in the step any more
	# write del in dgs
	if step != currentStep:	
		
		dgsWriter.writeStep(step)
		print "----"
		# print "step: {0}, stepVehicles: {1}, stepPoints: {2}, stepEdges: {3}".format(currentStep, len(stepVehicles), len(stepPoints), edgesStepCount)
		# print "step: {0}, runningVehicles: {1} ".format(currentStep, len(runningVehicles))

		if len(stepVehicles) > 0:
			# if a running vehice is not in the current step, remove from running
			nodesToDelete = []
			addedNodesCount = 0
			edgesToAdd = []
			edgesToDelete = []
			for runningVehicleId in runningVehicles.iterkeys():
				if not runningVehicleId in stepVehicles:
					nodesToDelete.append(runningVehicleId)
			for nodeId in nodesToDelete:
				for edgeToDelete in runningVehicles[nodeId]:
					edgesToDelete.append(formatEdgeId(nodeId, edgeToDelete))
				runningVehicles = removekey(runningVehicles, nodeId)
					
			# if a step vehicle is not in running, add, if is , write change
			for stepVehicleId,stepVehicleEdges in stepVehicles.iteritems():
				point = stepPoints[stepVehicleId]
				# if stepVehicleId == "337" or stepVehicleId == "344":
				# 	print "step node {0}: {1}".format(stepVehicleId, stepVehicleEdges)
				if not stepVehicleId in runningVehicles.keys():
					addedNodesCount += 1
					runningVehicles[stepVehicleId] = stepVehicleEdges
					# wrtie added nodes 
					dgsWriter.writeAddNode(stepVehicleId, point[0], point[1])
					# remember which edges to add
					for edgeToAdd in stepVehicleEdges:
						edgeId = formatEdgeId(stepVehicleId, edgeToAdd)
						if edgeToAdd not in runningVehicles:
							runningVehicles[edgeToAdd] = []
							point = stepPoints[edgeToAdd]
							dgsWriter.writeAddNode(edgeToAdd, point[0], point[1])
						elif stepVehicleId not in runningVehicles[edgeToAdd]:
							runningVehicles[edgeToAdd].append(stepVehicleId)
						if edgeId not in edgesToAdd:
							edgesToAdd.append(edgeId)
							# if edgeId=="871-1126":
							# 	print "{0}, node {1}-{2}, adding first time".format(currentStep, stepVehicleId, edgeToAdd)	
					
				else:
					# write changed nodes
					dgsWriter.writeChangeNode(stepVehicleId, point[0], point[1])
					# add/delete edges if changed
					currentEdges = runningVehicles[stepVehicleId]

					# if stepVehicleId=="871":
					# 	print "currentStep {2}, {3}, current {0}, new {1}".format(runningVehicles[stepVehicleId], stepVehicleEdges, currentStep, stepVehicleId)
					
					for currentEdge in currentEdges:
						if not currentEdge in stepVehicleEdges:
							# print "{0}-{1}".format(stepVehicleId, currentEdge)
							edgeId = formatEdgeId(stepVehicleId, currentEdge)
							node1Number = int(stepVehicleId)
							node2Number = int(currentEdge)
							if edgeId not in edgesToDelete:
								if node1Number < node2Number:
									edgesToDelete.append(edgeId)
								runningVehicles[stepVehicleId].remove(currentEdge)
								# if edgeId=="128-554":
								# 	print "currentStep {1}, deleting for node {3} edge: {0}, after: {2}".format(edgeId, currentStep, runningVehicles[stepVehicleId], stepVehicleId)
								

					for newEdge in stepVehicleEdges:
						if newEdge not in currentEdges:
							edgeId = formatEdgeId(stepVehicleId, newEdge)
							node1Number = int(stepVehicleId)
							node2Number = int(newEdge)
							if node1Number < node2Number:
								if edgeId not in edgesToAdd:
									edgesToAdd.append(edgeId)
									# if edgeId=="871-1126":
									# 	print "{0}, node {1}-{2}, adding in change".format(currentStep, stepVehicleId, newEdge)	
								runningVehicles[stepVehicleId].append(newEdge)
								

			# write deleted nodes
			for nodeId in nodesToDelete:
				dgsWriter.writeDelNode(nodeId)	
			# wrtite added edges
			for edgeId in edgesToAdd:
				if edgeId=="285-1026":
					print "{0}, node writitng {1}".format(currentStep, edgeId)
				edges = splitEdgeId(edgeId)
				if len(edges) == 2:
					dgsWriter.writeAddEdge(edgeId, edges[0], edges[1])
				else:
					print "Error. EdgeId in wrong format!"
			# write deleted edges
			for edgeId in edgesToDelete:
				dgsWriter.writeDelEdge(edgeId)
				if edgeId=="285-1026":
					print "{0}, node deleting {1}".format(currentStep, edgeId)

			# print runningVehicles["128"]

			print "step: {0}, addedNodes: {1}, deletedNodes {2}, edgesToAdd: {3}, edgesToDelete: {4} ".format(currentStep, addedNodesCount, len(nodesToDelete), len(edgesToAdd), len(edgesToDelete))

			# checkEdges(stepVehicles, stepPoints)
			# print "step: {0}, maxEdgeDistance: {1}".format(currentStep, maxEdgeDistance)

		# prepare to the next step
		currentStep = step
		edgesCount += edgesStepCount
		nodesCount += len(stepVehicles)
		edgesStepCount = 0
		
		addedNodesCount = 0
		deletedNodsCount = 0

		stepVehicles = {}
		stepPoints = {}

	# record step vehicle information (id, point, edges)
	vehicleId = str(elem[2])
	vehicleX = float(elem[3])
	vehicleY = float(elem[4])
	vehicleMac = str(elem[5])
	vehicleNumberOfEdges = int(elem[6])
	vehicleEdges = []
	for i in range(0,vehicleNumberOfEdges):
		neighborId = str(elem[7+i]).strip()
		if options.fromNS3:
			neighborId = macMap[elem[7+i]]
		vehicleEdges.append(neighborId)
		edgesStepCount += 1

	stepVehicles[vehicleId] = vehicleEdges
	stepPoints[vehicleId] = [vehicleX,vehicleY]
	
	return 0

def removekey(d, key):
    r = dict(d)
    del r[key]
    return r


#################

dgsWriter = DGSWriter(options.dgsFile)
dgsWriter.writeHeader("DGS004", "vanet", 0, 0)
if options.fromNS3:
	for line in fileinput.input(options.vanetFile):
		populateMacMap(line, args)
for line in fileinput.input(options.vanetFile):
	processLine(line, args)

print "nodesCount: " + str(nodesCount) + ", edgesCount: " + str(edgesCount)
